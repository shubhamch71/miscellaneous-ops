/**
 * Production-grade Declarative Jenkinsfile
 *
 * Features:
 * - Multibranch Pipeline friendly
 * - Gitea checkout, Checkmarx SAST, JFrog Artifactory for artifact & Docker
 * - Trivy image scanning, Cosign signing
 * - Dev, Staging, Prod deployments with Blue-Green strategy
 * - Istio weighted routing for production gradual traffic shift
 * - Rollback requires manual confirmation
 */

pipeline {
  agent { label 'jenkins-agent' }
  options {
    disableConcurrentBuilds()
    timestamps()
    ansiColor('xterm')
    timeout(time: 150, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '50', daysToKeepStr: '30'))
  }

  environment {
    APP_NAME           = "my-app"
    ARTIFACTORY_URL    = credentials('ARTIFACTORY_URL')
    ARTIFACTORY_CRED   = 'ARTIFACTORY_CRED'
    DOCKER_REG_CRED_ID = 'DOCKER_REG_CRED'
    GITEA_SSH_ID       = 'GITEA_SSH'
    CHECKMARX_USER_ID  = 'CHECKMARX_USER'
    CHECKMARX_PWD_ID   = 'CHECKMARX_PWD'
    CHECKMARX_URL      = credentials('CHECKMARX_URL')
    COSIGN_KEY_ID      = 'COSIGN_KEY'
    KUBE_DEV_ID        = 'KUBE_KUBECONFIG_DEV'
    KUBE_STG_ID        = 'KUBE_KUBECONFIG_STAGING'
    KUBE_PROD_ID       = 'KUBE_KUBECONFIG_PROD'
    SHORT_COMMIT       = "${env.GIT_COMMIT ?: 'manual'}".take(8)
    IMAGE_TAG          = "${env.SHORT_COMMIT}-${env.BUILD_NUMBER}"
    BUILD_INFO_NAME    = "${APP_NAME}"
    BUILD_INFO_NUMBER  = "${env.BUILD_NUMBER}"
    ARTIFACTORY_REPO   = "libs-release-local"
    ARTIFACTORY_DOCKER = "docker-local"
    CHECKMARX_FAIL_ON  = "High"
  }

  stages {
    stage('Init & Checkout') {
      steps {
        echo "Branch: ${env.BRANCH_NAME}"
        withCredentials([sshUserPrivateKey(credentialsId: env.GITEA_SSH_ID, keyFileVariable: 'GIT_SSH_KEY')]) {
          sh """
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            cp ${GIT_SSH_KEY} ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan -t rsa gitea.example.com >> ~/.ssh/known_hosts || true
            git clone --branch ${BRANCH_NAME} --depth 1 git@gitea.example.com:org/${APP_NAME}.git repo
          """
        }
        dir('repo') {
          script { env.WORKSPACE_REPO = pwd() }
          sh 'git rev-parse HEAD'
          script {
            if (!env.GIT_COMMIT) { env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim() }
            env.SHORT_COMMIT = env.GIT_COMMIT.take(8)
            env.IMAGE_TAG = "${env.SHORT_COMMIT}-${env.BUILD_NUMBER}"
          }
        }
      }
    }

    stage('Pre-commit & Linters') {
      steps {
        dir('repo') {
          sh '''
            echo "Running linters"
            if [ -f pom.xml ]; then mvn -q -DskipTests=true verify
            elif [ -f package.json ]; then npm ci && npm run lint || true
            elif [ -f go.mod ]; then go vet ./... || true
            fi
          '''
        }
      }
    }

    stage('Unit Tests & Coverage') {
      parallel {
        stage('Unit Tests') {
          steps { dir('repo') { sh 'echo "Unit tests placeholder"' } }
        }
        stage('Coverage Report') {
          steps { dir('repo') { sh 'echo "Coverage placeholder"' } }
        }
      }
    }

    stage('SCA / Dependency Scanning') {
      steps { dir('repo') { sh 'echo "Dependency scan placeholder"' } }
    }

    stage('SAST - Checkmarx') {
      steps { dir('repo') { sh 'echo "Checkmarx scan placeholder"' } }
    }

    stage('Build Artifact') {
      steps { dir('repo') { sh 'echo "Build artifact placeholder"' } }
    }

    stage('Generate SBOM') {
      steps { dir('repo') { sh 'echo "SBOM generation placeholder"' } }
    }

    stage('Build Container Image') {
      steps {
        dir('repo') {
          withCredentials([usernamePassword(credentialsId: env.DOCKER_REG_CRED_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PSW')]) {
            sh """
              IMAGE_FULL=${ARTIFACTORY_URL}/${ARTIFACTORY_DOCKER}/${APP_NAME}:${IMAGE_TAG}
              docker login ${ARTIFACTORY_URL} -u "$DOCKER_USER" -p "$DOCKER_PSW"
              docker build -t ${IMAGE_FULL} .
              docker push ${IMAGE_FULL}
              echo ${IMAGE_FULL} > image-fullname.txt
            """
          }
        }
      }
    }

    stage('Container Image Scan & Sign') {
      steps {
        dir('repo') {
          sh '''
            IMAGE_FULL=$(cat image-fullname.txt)
            trivy image --exit-code 1 --severity HIGH,CRITICAL ${IMAGE_FULL} || true
            cosign sign --key ${COSIGN_KEY_ID} ${IMAGE_FULL} || true
          '''
        }
      }
    }

    stage('Publish Artifacts & Build Info') {
      steps {
        dir('repo') {
          sh 'echo "Publish artifacts placeholder"'
        }
      }
    }

    stage('Deploy -> Dev') {
      steps {
        dir('repo') {
          withCredentials([file(credentialsId: env.KUBE_DEV_ID, variable: 'KUBECONFIG_FILE')]) {
            sh '''
              export KUBECONFIG=${KUBECONFIG_FILE}
              IMAGE_FULL=$(cat image-fullname.txt)
              helm upgrade --install ${APP_NAME}-dev charts/${APP_NAME} -f charts/${APP_NAME}/values-dev.yaml --set image.repository=${ARTIFACTORY_URL}/${ARTIFACTORY_DOCKER}/${APP_NAME} --set image.tag=${IMAGE_TAG} --namespace dev --create-namespace --wait --timeout 10m
            '''
          }
        }
      }
    }

    stage('Integration / E2E Tests on Dev') { steps { sh 'echo "Integration tests placeholder"' } }

    stage('Deploy -> Staging') {
      steps {
        dir('repo') {
          withCredentials([file(credentialsId: env.KUBE_STG_ID, variable: 'KUBECONFIG_FILE')]) {
            sh '''
              export KUBECONFIG=${KUBECONFIG_FILE}
              IMAGE_FULL=$(cat image-fullname.txt)
              helm upgrade --install ${APP_NAME}-stg charts/${APP_NAME} -f charts/${APP_NAME}/values-staging.yaml --set image.repository=${ARTIFACTORY_URL}/${ARTIFACTORY_DOCKER}/${APP_NAME} --set image.tag=${IMAGE_TAG} --namespace staging --create-namespace --wait --timeout 15m
            '''
          }
        }
      }
    }

    stage('Manual Approval for Prod') {
      steps {
        script {
          input message: "Approve promotion to PROD? Build: ${BUILD_INFO_NAME} #${BUILD_INFO_NUMBER}", ok: 'Promote to PROD'
        }
      }
    }

    stage('Deploy -> Prod (Blue-Green with Istio)') {
      steps {
        dir('repo') {
          withCredentials([file(credentialsId: env.KUBE_PROD_ID, variable: 'KUBECONFIG_FILE')]) {
            sh '''
              export KUBECONFIG=${KUBECONFIG_FILE}
              IMAGE_FULL=$(cat image-fullname.txt)
              # Deploy new version to blue/green namespace (green)
              helm upgrade --install ${APP_NAME}-green charts/${APP_NAME} -f charts/${APP_NAME}/values-prod-green.yaml --set image.repository=${ARTIFACTORY_URL}/${ARTIFACTORY_DOCKER}/${APP_NAME} --set image.tag=${IMAGE_TAG} --namespace prod-green --create-namespace --wait --timeout 20m
              # Shift Istio VirtualService traffic gradually (weight-based)
              kubectl apply -f k8s/istio-virtualservice-prod.yaml
            '''
          }
        }
      }
    }

    stage('Monitor & Adjust Traffic') {
      steps {
        input message: "Monitor metrics (latency, errors). Promote traffic to green?", ok: 'Shift 100% to green'
        dir('repo') {
          withCredentials([file(credentialsId: env.KUBE_PROD_ID, variable: 'KUBECONFIG_FILE')]) {
            sh '''
              export KUBECONFIG=${KUBECONFIG_FILE}
              # Update Istio VirtualService to route 100% to green deployment
              kubectl apply -f k8s/istio-virtualservice-prod-green.yaml
              # Optional: cleanup old blue deployment after successful traffic shift
            '''
          }
        }
      }
    }

    stage('Manual Rollback (if needed)') {
      when { expression { currentBuild.result == 'UNSTABLE' || currentBuild.result == 'FAILURE' } }
      steps {
        input message: "Deployment failed or metrics unhealthy. Rollback to previous stable (blue)?", ok: 'Rollback'
        dir('repo') {
          withCredentials([file(credentialsId: env.KUBE_PROD_ID, variable: 'KUBECONFIG_FILE')]) {
            sh '''
              export KUBECONFIG=${KUBECONFIG_FILE}
              # Switch Istio VirtualService back to blue
              kubectl apply -f k8s/istio-virtualservice-prod-blue.yaml
              # Optionally delete green deployment
              helm uninstall ${APP_NAME}-green -n prod-green || true
            '''
          }
        }
      }
    }

    stage('Post-deploy Smoke & Verification') { steps { sh 'echo "Smoke tests placeholder"' } }

    stage('Finalize: Tagging & Notifications') {
      steps {
        dir('repo') {
          sh '''
            echo "Tagging Git release if on main/release branch"
            if echo "${BRANCH_NAME}" | grep -Eq "^(main|master|release)"; then
              git tag -a "v${BUILD_INFO_NUMBER}-${SHORT_COMMIT}" -m "Release ${BUILD_INFO_NUMBER} - ${SHORT_COMMIT}" || true
              git push origin --tags || true
            fi
          '''
          echo "Send notifications (Slack/PagerDuty) placeholder"
        }
      }
    }

  }

  post {
    success { echo "Pipeline completed successfully. Build: ${BUILD_INFO_NAME} #${BUILD_INFO_NUMBER}" }
    unstable { echo "Pipeline unstable. Check test/scan reports." }
    failure { echo "Pipeline failed. Check archived artifacts." }
    always {
      archiveArtifacts artifacts: 'repo/**/checkmarx-report*.json, repo/**/trivy-image.json, repo/**/sbom.json, repo/image-fullname.txt', allowEmptyArchive: true
      junit allowEmptyResults: true, testResults: '**/surefire-reports/*.xml'
      cleanWs()
    }
  }
}
